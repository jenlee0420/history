class canvasImage {
    // 是否支持canvas
    support = (function () {
        return "getContext" in document.createElement('canvas');
    })()
    // 创建canvas
    createCanvas(width, height) {
        var canvas = document.createElement('canvas')
        canvas.width = width;
        canvas.height = height;
        return canvas
    }
    // 加载图片
    loadImage(url) {
        return new Promise((resolve, reject) => {
            var image = new Image()
            image.setAttribute('crossOrigin', 'anonymous'); // 解决使用网络图片跨域问题
            image.src = url
            image.onload = () => {
                resolve(image)
            }
        })
    }
    // 获取后缀
    getImageType(str) {
        let mimeType = 'image/jpeg';
        const outputType = str.match(/(image\/[\w]+)\.*/)[0];
        if (typeof outputType !== 'undefined') {
            mimeType = outputType;
        }
        return mimeType;
    }
    // 旋转方法
    rotate(url, degrees) {
        return new Promise((resolve, reject) => {
            this.loadImage(url).then(image => {
                // console.log(image)

                let w = image.naturalWidth;
                let h = image.naturalHeight;
                let cvs = this.createCanvas(w, h);
                let ctx = cvs.getContext('2d');
                ctx.save();
                if (degrees < 0) {
                    degrees = (degrees % 360) + 360
                } else {
                    degrees %= 360
                }
                // 左右90度
                console.log(degrees)
                let width = 0, height = 0
                if ([-90, 90, 270, -270].includes(degrees)) {
                    cvs.width = h;
                    cvs.height = w;
                    ctx.translate(h / 2, w / 2);
                    ctx.rotate(degrees * Math.PI / 180);
                    ctx.drawImage(image, -w / 2, -h / 2);
                } else if (degrees == 0) {
                    // 左右0或180度
                    // console.log(image,w,h)
                    cvs.width = w;
                    cvs.height = h;
                    // ctx.translate(w / 2, h / 2)
                    // ctx.translate(w / 2, h / 2);
                    // ctx.rotate(degrees * Math.PI / 180);
                    // ctx.translate(-w / 2, -h / 2);
                    // ctx.drawImage(image, 0,0,w,h);
                    ctx.drawImage(image, 0, 0, w, h);
                } else if (degrees == 180 || degrees == -180) {
                    cvs.width = w;
                    cvs.height = h;
                    ctx.rotate(degrees * Math.PI / 180)
                    ctx.drawImage(image, -w, -h, w, h)
                    // ctx.drawImage(image, 0,0,w,h);
                }
                // let x=0,y=0;
                // let rad = degrees * Math.PI/180
                // ctx.transform( Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), x + w / 2,  y + h / 2)
                // ctx.drawImage(image, -w / 2,  -h / 2, w, h)
                // ctx.restore();

                // ctx.rotate(degrees * Math.PI / 180)
                // ctx.drawImage(image,-w/2,-h/2)
                // ctx.drawImage(image, -width / 2, -height / 2, w, h)
                ctx.restore()


                cvs.toBlob(function (blob) {
                    resolve(blob);
                    cvs = null;
                    ctx = null;
                })
            })
        })
    }
    // 选工作旋转90度
    slideLeft(url) {
        const degrees = -90 //* Math.PI / 180;
        return new Promise(resolve => {
            this.rotate(url, degrees).then(blob => {
                resolve(blob)
            })
        })
    }
    // 向右旋转90度
    slideRight(url) {
        const degrees = 90 //* Math.PI / 180;
        return new Promise(resolve => {
            this.rotate(url, degrees).then(blob => {
                resolve(blob)
            })
        })
    }
    // 翻转 x代表水平 y代表垂直 1为反转 0为不翻转
    flip(url, x, y) {
        return new Promise((resolve, reject) => {
            this.loadImage(url).then(image => {
                // console.log(image)
                let w = image.naturalWidth;
                let h = image.naturalHeight;
                let cvs = this.createCanvas(w, h);
                let ctx = cvs.getContext('2d');
                ctx.save();
                ctx.scale(-1 * x, -1 * y)
                ctx.drawImage(image, x > 0 ? -w : 0, y > 0 ? -h : 0);
                ctx.restore();

                cvs.toBlob(function (blob) {
                    resolve(blob);
                    cvs = null;
                    ctx = null;
                })
            })
        })
    }
    // 水平翻转
    flipX(url) {
        return new Promise(resolve => {
            this.flip(url, 1, -1).then(blob => {
                resolve(blob)
            })
        })
    }
    // 垂直翻转
    flipY(url) {
        return new Promise(resolve => {
            this.flip(url, -1, 1).then(blob => {
                resolve(blob)
            })
        })
    }
    // 将文件类型转换成base64
    fileToBase64(file) {
        return new Promise((resolve, reject) => {
            var r = new FileReader()
            r.onload = (e) => {
                resolve(e.target.result)
            }
            r.readAsDataURL(file);
        })
    }
    //将网络图片url转换成base64
    urlToBase64(url) {
        return new Promise((resolve, reject) => {
            this.loadImage(url).then(image => {
                var cvs = this.createCanvas(image.width, image.height)
                var ctx = cvs.getContext('2d')
                ctx.drawImage(image, 0, 0, image.width, image.height);
                var dataURL = cvs.toDataURL();
                resolve(dataURL)
            })
        })
    }
    // url转换成blob图片地址
    urlToBlob(url) {
        return new Promise(resolve => {
            this.loadImage(url).then(image => {
                var canvas = this.createCanvas(image.width, image.height)
                var context = canvas.getContext('2d')
                context.drawImage(image, 0, 0, image.width, image.height)
                var blob = canvas.toBlob((blob) => {
                    resolve(blob)
                })
            })
        })
    }
    // 将base64图片转换成blob类型
    base64ToBlob(base64) {
        return new Promise(resolve => {
            var arr = base64.split(','), mime = arr[0].match(/:(.*?);/)[1],
                bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            resolve(new Blob([u8arr], { type: mime }))
        })
    }
    // 将base64转换成文件
    base64ToFile(base64, filename) {
        return new Promise(resolve => {
            var arr = base64.split(','), mime = arr[0].match(/:(.*?);/)[1],
                bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            resolve(new File([u8arr], filename, { type: mime }))
        })
    }

    /**
     *  压缩图片(上传时)
     * @param {*} file 图片File
     * @param {*} quality 质量(0~1)
     * @param {*} mime 如果要将图片转成新类型时传递，否则保持原图片格式
     */
    compressImage(file, quality, mime) {
        return new Promise(resolve => {
            // this.fileToBase64(file).then(base64 => {
            let base64 = URL.createObjectURL(file)
            this.loadImage(base64).then(image => {
                var canvas = this.createCanvas()
                var context = canvas.getContext('2d')
                canvas.width = image.width
                canvas.height = image.height
                context.drawImage(image, 0, 0, image.width, image.height)
                if (quality < 0 || quality > 1) {
                    resolve(file)
                    return
                }
                // let dataurl = canvas.toDataURL(file.type, quality)
                // this.base64ToFile(dataurl, file.name).then(newFile => {
                //     resolve(newFile)
                // })
                canvas.toBlob(function (blob) {
                    const newFile = new File([blob], file.name, {
                        type: mime ? mime : file.type,//file.type,
                        lastModified: Date.now()
                    })
                    resolve(newFile)
                }, mime ? mime : file.type, quality) // 由于png无法进行质量压缩，所以统一将png转成jpg
            }).catch(err => {
                reject(err)
            })
        })
        // })
    }

}

export default new canvasImage()